# -*- coding: utf-8 -*-
"""
/***************************************************************************
 renderUP
                                 A QGIS plugin
 编制方案渲染出图工具
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-12-28
        git sha              : $Format:%H$
        copyright            : (C) 2023 by mono zou
        email                : zou_mono@sina.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtWidgets import QMessageBox, QMenu, QToolButton
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtWidgets import QAction

# Initialize Qt resources from file resources.py
from qgis._core import QgsProject, QgsMessageLog, Qgis, QgsSettings, QgsStyle
from qgis._gui import QgsStyleManagerDialog

from .core.export import bacth_export
from .core.image import add_tianditu_basemap, add_extra_map, get_extra_map_icon
from .ui.setting_dlg import SettingDialog
from .utils import iconlib, TianMapInfo, extra_maps, get_qset_name, PLUGIN_NAME, single_window
# Import the code for the dialog
from .ui.render_dlg import renderDialog
import os.path
from .resources_rc import *

# import pydevd_pycharm
# pydevd_pycharm.settrace('localhost', port=53100, stdoutToServer=True, stderrToServer=True)

class renderUP:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # 设置工具栏
        self.toolbar = self.iface.addToolBar("编制方案渲染出图工具栏")
        self.toolbar.setObjectName("renderUPToolbar")
        self.toolbar.setToolTip("编制方案渲染出图工具栏")

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'renderUP_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = {}
        self.qset = QgsSettings()
        if not self.qset.contains(f"{PLUGIN_NAME}/tianditu/key"):
            # 初始化
            self.qset.setValue(f"{PLUGIN_NAME}/tianditu/key", "")
            self.qset.setValue(f"{PLUGIN_NAME}/tianditu/keyisvalid", False)
            self.qset.setValue(f"{PLUGIN_NAME}/tianditu/random", True)
            self.qset.setValue(f"{PLUGIN_NAME}/tianditu/subdomain", "t0")

        if not self.qset.contains(f"{PLUGIN_NAME}/extra/lastpath"):
            self.qset.setValue(f"{PLUGIN_NAME}/extra/lastpath", os.path.expanduser("~"))

        if not self.qset.contains(f"{PLUGIN_NAME}/extra/out_width"):
            self.qset.setValue(f"{PLUGIN_NAME}/extra/out_width", 1920)
        if not self.qset.contains(f"{PLUGIN_NAME}/extra/out_height"):
            self.qset.setValue(f"{PLUGIN_NAME}/extra/out_height", 1080)
        if not self.qset.contains(f"{PLUGIN_NAME}/extra/out_resolution"):
            self.qset.setValue(f"{PLUGIN_NAME}/extra/out_resolution", 300)
        if not self.qset.contains(f"{PLUGIN_NAME}/extra/out_format"):
            self.qset.setValue(f"{PLUGIN_NAME}/extra/out_format", 'png')


        self.qset.value(get_qset_name("export"), None)
        self.qset.value(get_qset_name("outpath"), None)
        self.qset.value(get_qset_name("outpath"), None)

        self.menu = self.tr(u'&render urban planning')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('renderUP', message)

    def add_action(
            self,
            icon,
            text,
            callback,
            svg=True,
            enabled_flag=True,
            add_to_menu=False,
            add_to_toolbar=False,
            status_tip=None,
            whats_this=None,
            parent=None):
        """Add a toolbar icon to the toolbar.

        :param svg:
        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        # if svg:
        #     icon = QIcon(QPixmap(icon_path))
        # else:
        #     icon = QIcon(icon_path)

        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        # self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        # # 添加 Action
        # self.actions['image'] = self.add_action(iconlib['image'], text=self.tr(u'影像底图'), callback=self.run_image,
        #                                         parent=self.iface.mainWindow())
        # self.toolbar.addAction(self.actions["image"])

        # 天地图添加 Action
        menu = QMenu()
        menu.setObjectName("TianDiTuAddMap")
        for map_type, map_name in TianMapInfo.items():
            menu.addAction(
                iconlib["tianditu"],
                map_name,
                lambda maptype_=map_type: add_tianditu_basemap(maptype_, self.iface, self.toolbar),
            )

        menu.addSeparator()

        # 添加其他图源 Action
        self.actions["extra_map"] = menu.addAction(iconlib["extra_map"], "其他图源")
        extra_map_menu = QMenu()
        for map_data in extra_maps:
            if map_data["name"] != "Separator":
                icon = get_extra_map_icon(map_data)
                extra_map_menu.addAction(
                    icon,
                    map_data["name"],
                    lambda map_data_=map_data: add_extra_map(map_data_),
                )
            else:
                extra_map_menu.addSeparator()
        self.actions["extra_map"].setMenu(extra_map_menu)

        self.image_button = QToolButton()
        self.image_button.setMenu(menu)
        self.image_button.setPopupMode(QToolButton.MenuButtonPopup)
        self.image_button.setText("添加底图")
        self.image_button.setIcon(iconlib["image"])
        self.image_button.setToolTip("添加底图")
        self.image_button = self.toolbar.addWidget(self.image_button)

        self.actions['render'] = self.add_action(iconlib['render'], text=self.tr(u'样式渲染'), callback=self.run_render,
                                                parent=self.iface.mainWindow())
        self.toolbar.addAction(self.actions["render"])

        self.actions['export'] = self.add_action(iconlib['export'], text=self.tr(u'批量导出'), callback=self.run_export,
                                                 parent=self.iface.mainWindow())
        self.toolbar.addAction(self.actions["export"])

        self.actions['setting'] = self.add_action(iconlib['setting'], text=self.tr(u'设置'), callback=self.run_setting,
                                                 parent=self.iface.mainWindow())
        self.toolbar.addAction(self.actions["setting"])

        # will be set False in run()
        self.first_start = True

        self.project = QgsProject.instance()

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for k, action in self.actions.items():
            # self.iface.removePluginMenu(
            #     self.tr(u'&render urban planning'),
            #     action)
            self.iface.removeToolBarIcon(action)

    def run_image(self):
        proj_id = self.project.crs().authid()
        QgsMessageLog.logMessage("当前坐标系统:{}, 符合输入要求.".format(proj_id), level=Qgis.MessageLevel.Info)
        if proj_id != "EPSG:3857" and proj_id != "ESPG:4547":
            QMessageBox.warning(None, '警告', '为了配合影像底图使用，请将当前坐标系统调整为web墨卡托投影(EPSG:3857)或者国家大地2000投影(EPSG:4547)',
                                QMessageBox.Ok)
            return

    def run_render(self):
        """Run method that performs all the real work"""

        # dlg = QgsStyleManagerDialog(
        #     QgsStyle.defaultStyle()
        # )
        #
        # dlg.show()
        # dlg.exec_()

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if single_window.m_frmRender is None:
            frm = renderDialog(iface=self.iface, parent=self.iface.mainWindow())
            single_window.m_frmRender = frm
        else:
            frm = single_window.m_frmRender

        frm.show()
        # Run the dialog event loop
        # result = self.dlg.exec_()
        # See if OK was pressed
        # if result:
        #     # Do something useful here - delete the line containing pass and
        #     # substitute with your code.
        #     pass

    def run_setting(self):
        if single_window.m_frmSetting is None:
            frm = SettingDialog(project=self.project, extra_map_action=self.actions["extra_map"])
            single_window.m_frmSetting = frm
        else:
            frm = single_window.m_frmSetting

        frm.exec_()

    def run_export(self):
        be = bacth_export(self.iface)
        be.run()
